/*
 * Copyright (c) 2014. Real Time Genomics Limited.
 *
 * Use of this source code is bound by the Real Time Genomics Limited Software Licence Agreement
 * for Academic Non-commercial Research Purposes only.
 *
 * If you did not receive a license accompanying this file, a copy must first be obtained by email
 * from support@realtimegenomics.com.  On downloading, using and/or continuing to use this source
 * code you accept the terms of that license agreement and any amendments to those terms that may
 * be made from time to time by Real Time Genomics Limited.
 */

package com.rtg.tabix;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import com.rtg.tabix.TabixIndexer.BedIndexerFactory;
import com.rtg.tabix.TabixIndexer.TabixOptions;
import com.rtg.tabix.TabixIndexer.TsvIndexerFactory;
import com.rtg.util.Resources;
import com.rtg.util.io.FileUtils;
import com.rtg.util.io.IOUtils;
import com.rtg.util.io.TestDirectory;
import com.rtg.util.test.BgzipFileHelper;
import com.rtg.util.test.FileHelper;

import htsjdk.samtools.util.BlockCompressedInputStream;

import junit.framework.TestCase;

/**
 * Test class
 */
public class TabixIndexerTest extends TestCase {
  private File mDir;
  @Override
  public void setUp() throws IOException {
    mDir = FileUtils.createTempDir("tabix", "test");
  }

  @Override
  public void tearDown() {
    assertTrue(FileHelper.deleteAll(mDir));
    mDir = null;
  }

  private File file(String name) {
    return new File(mDir, name);
  }

  //avoid unclosed streams and try/finally blocks
  private InputStream lazyStream(File f) throws IOException {
    final byte[] data = IOUtils.readData(f);
    return new ByteArrayInputStream(data);
  }

  public void test() throws Exception {
    final File index = file("index");
    final File sam = FileHelper.resourceToFile("com/rtg/sam/resources/test.sam.gz", file("test.sam.gz"));
    new TabixIndexer(sam, index).saveSamIndex();
    final String myBai = IndexTestUtils.tbiIndexToUniqueString(new BlockCompressedInputStream(lazyStream(index)));
    final String exp;
    try (InputStream baiIs = new BlockCompressedInputStream(Resources.getResourceAsStream("com/rtg/sam/resources/test.sam.gz.tbi"))) {
      exp = IndexTestUtils.tbiIndexToUniqueString(baiIs);
    }

    assertEquals(exp, myBai);
  }

  public void testUnordered() throws Exception {
    final File dir = FileHelper.createTempDirectory();
    try {
      final File in = BgzipFileHelper.resourceToBgzipFile("com/rtg/sam/resources/unmated-out-of-order.sam", new File(dir, "unmated-out-of-order.sam.gz"));
      final File tabixFile = new File(in.getPath() + ".tbi");
      try {
        new TabixIndexer(in, tabixFile).saveSamIndex();
        fail();
      } catch (UnindexableDataException e) {
        assertFalse(tabixFile.exists());
        assertEquals("File is not sorted", e.getMessage());
      }
    } finally {
      assertTrue(FileHelper.deleteAll(dir));
    }
  }

  //the expected file here is not generated by tabix because the bug we are testing for hasn't been fixed in the c-tabix codebase
  public void testLinearIndexBug() throws Exception {
    final File index = file("index");
    final File input = FileHelper.resourceToFile("com/rtg/sam/resources/tabix.sam.gz", file("tabix.sam.gz"));
    new TabixIndexer(input, index).saveSamIndex();
    final String myBai = IndexTestUtils.tbiIndexToUniqueString(new BlockCompressedInputStream(lazyStream(index)));
    final String exp;
    try (InputStream baiIs = new BlockCompressedInputStream(Resources.getResourceAsStream("com/rtg/sam/resources/tabix.sam.gz.tbi"))) {
      exp = IndexTestUtils.tbiIndexToUniqueString(baiIs);
    }

    assertEquals(exp, myBai);
  }

  public void testLinearIndexOk() throws Exception {
    final File index = file("index");
    final File input = FileHelper.resourceToFile("com/rtg/sam/resources/tabixheader.sam.gz", file("tabixheader.sam.gz"));
    new TabixIndexer(input, index).saveSamIndex();
    final String myBai = IndexTestUtils.tbiIndexToUniqueString(new BlockCompressedInputStream(lazyStream(index)));
    final String exp;
    try (InputStream baiIs = new BlockCompressedInputStream(Resources.getResourceAsStream("com/rtg/sam/resources/tabixheader.sam.gz.tbi"))) {
      exp = IndexTestUtils.tbiIndexToUniqueString(baiIs);
    }

    assertEquals(exp, myBai);
  }

  //tests a mixed file of mapped and unmapped
  public void testMixed() throws Exception {
    final File index = file("index");
    final File input = FileHelper.resourceToFile("com/rtg/sam/resources/mixed.sam.gz", file("mixed.sam.gz"));
    new TabixIndexer(input, index).saveSamIndex();

    final String myBai = IndexTestUtils.tbiIndexToUniqueString(new BlockCompressedInputStream(lazyStream(index)));
    final String exp;
    try (InputStream baiIs = new BlockCompressedInputStream(Resources.getResourceAsStream("com/rtg/sam/resources/mixed.sam.gz.tbi"))) {
      exp = IndexTestUtils.tbiIndexToUniqueString(baiIs);
    }

    assertEquals(exp, myBai);
  }

  public void testLargish() throws Exception {
    final File index = file("index");
    final File input = FileHelper.resourceToFile("com/rtg/sam/resources/mmmm.sam.gz", file("mmmm.sam.gz"));
    new TabixIndexer(input, index).saveSamIndex();
    final String myBai = IndexTestUtils.tbiIndexToUniqueString(new BlockCompressedInputStream(lazyStream(index)));
    final String exp;
    try (InputStream baiIs = new BlockCompressedInputStream(Resources.getResourceAsStream("com/rtg/sam/resources/mmmm.sam.gz.tbi"))) {
      exp = IndexTestUtils.tbiIndexToUniqueString(baiIs);
    }

    assertEquals(exp, myBai);
  }

  public void testVcf() throws Exception {
    final File index = file("index");
    final File input = FileHelper.resourceToFile("com/rtg/sam/resources/vcf.txt.gz", file("vcf.txt.gz"));
    new TabixIndexer(input, index).saveVcfIndex();
    final String myBai = IndexTestUtils.tbiIndexToUniqueString(new BlockCompressedInputStream(lazyStream(index)));
    final String exp;
    try (InputStream baiIs = new BlockCompressedInputStream(Resources.getResourceAsStream("com/rtg/sam/resources/vcf.txt.gz.tbi"))) {
      exp = IndexTestUtils.tbiIndexToUniqueString(baiIs);
    }

    assertEquals(exp, myBai);
  }

  public void testFactories() throws Exception {

    final TsvIndexerFactory tif = new TabixIndexer.TsvIndexerFactory();
    TabixOptions options = tif.getOptions();
    assertEquals(TabixOptions.FORMAT_GENERIC, options.mFormat);
    assertEquals(0, options.mSeqCol);
    assertEquals(1, options.mStartCol);
    assertEquals(1, options.mEndCol);
    assertEquals('#', options.mMeta);
    assertEquals(0, options.mSkip);
    assertFalse(options.mZeroBased);
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    try {
      try (InputStream is = Resources.getResourceAsStream("com/rtg/sam/resources/mmmm.sam.gz")) {
        assertNotNull(tif.getReader(is));
      }
    } finally {
      os.close();
    }

    final BedIndexerFactory bif = new TabixIndexer.BedIndexerFactory(0);
    options = bif.getOptions();
    assertEquals(TabixOptions.FORMAT_GENERIC | 0x10000, options.mFormat);
    assertEquals(0, options.mSeqCol);
    assertEquals(1, options.mStartCol);
    assertEquals(2, options.mEndCol);
    assertEquals('#', options.mMeta);
    assertEquals(0, options.mSkip);
    assertTrue(options.mZeroBased);
    os = new ByteArrayOutputStream();
    try {
      try (InputStream is = Resources.getResourceAsStream("com/rtg/sam/resources/mmmm.sam.gz")) {
        assertNotNull(bif.getReader(is));
      }
    } finally {
      os.close();
    }
  }

  public void testIsBedSkipLine() {
    assertTrue(TabixIndexer.isBedSkipLine("track type=bedGraph description=foo"));
    assertTrue(TabixIndexer.isBedSkipLine("track\ttype=bedGraph\tdescription=foo"));
    assertTrue(TabixIndexer.isBedSkipLine("#whatever man"));
    assertTrue(TabixIndexer.isBedSkipLine("browser "));
    assertFalse(TabixIndexer.isBedSkipLine("simulatedSequence1 0  6  2"));
    assertFalse(TabixIndexer.isBedSkipLine("simulatedSequence1 0 6 2"));
    assertFalse(TabixIndexer.isBedSkipLine("simulatedSequence1\t0\t6\t2"));
    assertFalse(TabixIndexer.isBedSkipLine("tracks 0 6 2"));
    assertFalse(TabixIndexer.isBedSkipLine("track17 0 6 2"));
    assertFalse(TabixIndexer.isBedSkipLine("track"));
  }

  public void testEmptyFileAsInput() throws IOException, UnindexableDataException {
    final File f = FileUtils.createTempDir("temp", "tabixindextest");
    try {
      final File file = new File(f, "regions.bed.gz");
      final OutputStream o = FileUtils.createOutputStream(file, true, false, true);
      o.close();
      new TabixIndexer(file, new File(file.getParent(), file.getName() + TabixIndexer.TABIX_EXTENSION)).saveBedIndex();
    } finally {
      assertTrue(FileHelper.deleteAll(f));
    }
  }

  public void testZeroLength() throws Exception {
    try (TestDirectory td = new TestDirectory()) {
      final File blankFile = new File(td, "blank");
      assertTrue(blankFile.createNewFile());

      final File indexOutFile = new File(td, blankFile.getName() + TabixIndexer.TABIX_EXTENSION);

      new TabixIndexer(blankFile, indexOutFile).saveVcfIndex();

      final String idx = FileHelper.gzFileToString(indexOutFile);
      assertEquals("TBI\u0001"
                 + "\u0000\u0000\u0000\u0000"
                 + "\u0002\u0000\u0000\u0000"
                 + "\u0001\u0000\u0000\u0000"
                 + "\u0002\u0000\u0000\u0000"
                 + "\u0000\u0000\u0000\u0000"
                 + "#"
                 + "\u0000\u0000\u0000\u0000"
                 + "\u0000\u0000\u0000\u0000"
                 + "\u0000\u0000\u0000", idx);
    }
  }
}
