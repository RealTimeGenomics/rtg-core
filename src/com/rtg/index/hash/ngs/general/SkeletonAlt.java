/*
 * Copyright (c) 2014. Real Time Genomics Limited.
 *
 * Use of this source code is bound by the Real Time Genomics Limited Software Licence Agreement
 * for Academic Non-commercial Research Purposes only.
 *
 * If you did not receive a license accompanying this file, a copy must first be obtained by email
 * from support@realtimegenomics.com.  On downloading, using and/or continuing to use this source
 * code you accept the terms of that license agreement and any amendments to those terms that may
 * be made from time to time by Real Time Genomics Limited.
 */
package com.rtg.index.hash.ngs.general;

import com.rtg.util.integrity.Exam;
import com.rtg.util.integrity.IntegralAbstract;

/**
 * Does the tricky calculations necessary for finding a mask which fits the
 * requested constraints.
 * Attempts to keep the effective read length equal tot he supplied read length.
 * In some cases this isn't possible. See <code>Skeleton</code> for a more robust
 * version that always works but at expense of shorter effective read lengths.
 */
public final class SkeletonAlt extends IntegralAbstract {

  private final int mReadLength;

  private final int mWindowLength;

  private final int mSubstitutions;

  private final int mIndels;

  private final int mWindowLengthMin;

  private final int mWindowLengthMax;

  private final int mChunkLength;

  private final int mChunks;

  private final int mChunksSmall;

  private final int mChunksBig;

  private final int mWindowChunks;

  private final boolean mValid;

  /**
   * @param readLength lengths of reads.
   * @param windowLength minimum length of the window used for indexing.
   * @param substitutions minimum number of substitution that will be found.
   * @param indels minimum number of indels that will be found.
   */
  public SkeletonAlt(final int readLength, final int windowLength, final int substitutions, final int indels) {
    mIndels = indels;
    mReadLength = readLength;
    mSubstitutions = substitutions;
    mWindowLength = windowLength;
    final boolean inOk =
      mReadLength > 0 //&& mReadLength <= 65
      && mWindowLength > 0
      && mWindowLength <= mReadLength
      && mSubstitutions >= 0
      && mSubstitutions <= (mReadLength - mWindowLength)
      && mWindowLength + mSubstitutions <= 32
      && mIndels >= 0 && mIndels <= mSubstitutions;
      if (!inOk) {
        mWindowLengthMin = -1;
        mWindowLengthMax = -1;
        mChunkLength = -1;
        mChunks = -1;
        mChunksSmall = -1;
        mChunksBig = -1;
        mWindowChunks = -1;
        mValid = false;
        return;
      }
      int k = 1;
      while (true) {
        if (k > mReadLength - mSubstitutions) {
          mWindowLengthMin = -1;
          mWindowLengthMax = -1;
          mChunkLength = -1;
          mChunks = -1;
          mChunksSmall = -1;
          mChunksBig = -1;
          mWindowChunks = -1;
          mValid = false;
          break;
        }

        final int c = k + mSubstitutions;
        assert c <= mReadLength;
        final int t = mReadLength / c;
        assert t >= 1;
        final int b = mReadLength - t * c;
        assert b < c;
        final int a = c - b;
        final int w = a >= k ? k * t : k * t + k - a;
        final int wm = b >= k ? k * (t + 1) : k * t + b;
        if (w >= mWindowLength && wm <= 32) {
          mWindowLengthMin = w;
          mWindowLengthMax = wm;
          mChunkLength = t;
          mChunks = c;
          mChunksSmall = a;
          mChunksBig = b;
          mWindowChunks = k;
          mValid = true;
          break;
        }
        k++;
      }

      integrity();
  }

  /**
   * Compte the number of different masks generated by this skeleton.
   * Ignores tweaking for indels.
   * @return the number of different masks.
   */
  long numberMasks() {
    return Util.binomial(mChunks, mSubstitutions);
  }

  /**
   * Check if inputs used for construction lead to a valid
   * skeleton.
   * @return true iff the constraints have been satisfied.
   */
  public boolean valid() {
    return mValid;
  }

  @Override
  public void toString(final StringBuilder sb) {
    sb.append("Inputs:").append(mValid ? "" : "invalid").append(LS);
    sb.append("  Read length   ").append(mReadLength).append(LS);
    sb.append("  Window length ").append(mWindowLength).append(LS);
    sb.append("  Substitutions ").append(mSubstitutions).append(LS);
    sb.append("  Indels        ").append(mIndels).append(LS);
    if (!mValid) {
      return;
    }
    sb.append("Computed:").append(LS);
    sb.append("  Chunk length  ").append(mChunkLength).append(LS);
    sb.append("  Small chunks  ").append(mChunksSmall).append(LS);
    sb.append("  Big chunks    ").append(mChunksBig).append(LS);
    sb.append("  Window chunks ").append(mWindowChunks).append(LS);
    sb.append("  Window actual ").append(mWindowLengthMin).append(LS);
    sb.append("  Number masks  ").append(numberMasks()).append(LS);
  }

  @Override
  public boolean integrity() {
    if (!mValid) {
      Exam.assertEquals(mWindowLengthMin, -1);
      Exam.assertEquals(mWindowLengthMax, -1);
      Exam.assertEquals(mChunksSmall, -1);
      Exam.assertEquals(mChunksBig, -1);
      Exam.assertEquals(mChunkLength, -1);
      Exam.assertEquals(mChunks, -1);
      Exam.assertEquals(mWindowChunks, -1);
      return true;
    }
    Exam.assertTrue(mReadLength > 0 && mReadLength <= 64);
    Exam.assertTrue(mWindowLength > 0 && mWindowLength <= 32);
    Exam.assertTrue(mWindowLength <= mReadLength);
    Exam.assertTrue(mSubstitutions >= 0 && mSubstitutions <= (mReadLength - mWindowLength));
    Exam.assertTrue(mWindowLength + mSubstitutions <= 32);
    Exam.assertTrue(mIndels >= 0 && mIndels <= mSubstitutions);

    Exam.assertTrue("" + mWindowLengthMin + this.toString(), mWindowLengthMin > 0 && mWindowLengthMin <= 32);
    Exam.assertTrue(mWindowLengthMin <= mReadLength);
    Exam.assertTrue(mWindowLengthMin >= mWindowLength);
    Exam.assertTrue(mChunkLength > 0);
    Exam.assertEquals(mChunks, mChunksSmall + mChunksBig);
    Exam.assertTrue(mChunksSmall > 0);
    Exam.assertTrue(mChunksBig >= 0);
    Exam.assertTrue(this.toString(), mReadLength == mChunksSmall * mChunkLength + mChunksBig * (mChunkLength + 1));

    if (mWindowChunks <= mChunksSmall) {
      Exam.assertEquals(mWindowLengthMin, mWindowChunks * mChunkLength);
    } else {
      Exam.assertEquals(mWindowLengthMin, mWindowChunks * mChunkLength + mWindowChunks - mChunksSmall);
      Exam.assertTrue(this.toString(), mWindowLengthMin == mChunksSmall * mChunkLength + (mWindowChunks - mChunksSmall) * (mChunkLength + 1));
    }
    Exam.assertTrue(mWindowLengthMax <= 32);
    Exam.assertTrue(mWindowLengthMin <= mWindowLengthMax);
    if (mWindowChunks <= mChunksBig) {
      Exam.assertEquals(mWindowLengthMax, mWindowChunks * (mChunkLength + 1));
    } else {
      Exam.assertEquals(mWindowLengthMax, mWindowChunks * mChunkLength + mChunksBig);
      Exam.assertTrue(this.toString(), mWindowLengthMax == mChunksBig * (mChunkLength + 1) + (mWindowChunks - mChunksBig) * mChunkLength);
    }
    Exam.assertEquals(mSubstitutions + mWindowChunks, mChunksSmall + mChunksBig);
    return true;
  }

  /**
   * @param args command line arguments: read length, window size, substitutions, indels.
   */
  public static void main(final String[] args) {
    final int r = Integer.parseInt(args[0]);
    final int w = Integer.parseInt(args[1]);
    final int s = Integer.parseInt(args[2]);
    final int i = Integer.parseInt(args[3]);
    final SkeletonAlt sk = new SkeletonAlt(r, w, s, i);
    sk.integrity();
    System.out.println(sk);
  }

}
